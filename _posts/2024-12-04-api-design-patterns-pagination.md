---
layout: post
title: Пагинация в АПИ
date: 2024-12-04 00:23:30 +0000
categories: [Заметки из книг]
tags: [Паттерны проектирования API, Заметки из книг]
---

![](assets/img/memes/???.jpg){: w="300" .shadow }

### Пагинация в API

Сегодня хочу поделиться кратким пересказом главы из книги ["API Design Patterns" Дж. Дж. Гивакса](https://www.oreilly.com/library/view/api-design-patterns/9781617295850), посвящённой пагинации в API. 

#### Зачем нужна пагинация?  
Когда в API нужно работать с большими объёмами данных, важно обеспечить удобный механизм извлечения данных. Это помогает избежать ситуаций, когда запросы становятся слишком большими или перегружающими сервер. Пагинация — это решение, которое делит данные на управляемые части, позволяя клиенту извлекать их по частям.

Кроме того, пагинация обеспечивает гибкость: если требуется полный экспорт всех данных, API может поддерживать этот сценарий, предоставляя дополнительные механизмы для выборки всех данных.

#### Обзор пагинации  
Пагинация позволяет делить данные на страницы и передавать указатели для перехода от одной страницы к другой. Вместо того, чтобы получать все данные сразу, клиент получает только часть данных, что снижает нагрузку на сервер и ускоряет процесс.

Такой подход идеален для работы с большими наборами данных, где важно быстро и удобно извлекать только необходимую информацию.

#### Реализация пагинации  
Чтобы реализовать пагинацию, API использует два основных поля:  
- **pageToken** — непрозрачный идентификатор, который указывает на точку продолжения.  
- **maxPageSize** — максимальное количество элементов, которые клиент хочет получить.

В ответе API возвращает два параметра:  
- **nextPageToken** — маркер для запроса следующей страницы данных.  
- Набор данных для текущей страницы.

Таким образом, клиент получает возможность делать последовательные запросы и получать данные по частям.

##### Размер страницы  
Размер страницы может быть либо максимальным (чтобы обеспечить быструю обработку запроса), либо точным, что бывает сложным для больших объёмов данных. Параметр **maxPageSize** определяет максимальное количество элементов, которое можно вернуть в одном запросе. Это значение помогает серверу не перегружаться, даже если клиент запрашивает очень большой объём данных.

По умолчанию размер страницы может быть установлен на разумное значение, например, 10 или 100 результатов, в зависимости от размера данных.

##### Верхний и нижний предел  
Важно ограничивать максимальное значение для **maxPageSize**. Сервер должен отклонять запросы с отрицательным значением и, в случае чрезмерно большого размера, возвращать допустимое количество данных, соблюдая ограничения по времени.

#### Маркеры страниц  
Маркеры страниц играют ключевую роль в пагинации. Они обеспечивают клиенту возможность перехода на следующую страницу, но их структура должна быть непрозрачной. Например, маркеры должны быть зашифрованы, чтобы скрыть внутреннюю логику работы API.

Критерием завершения пагинации является **пустой маркер страницы**. Это сигнализирует, что больше данных нет, и процесс завершён.

##### Прозрачность маркера  
Маркеры должны быть непрозрачными для клиентов, то есть они должны содержать всю информацию, необходимую для продолжения работы, но при этом быть скрытыми от потребителей. Это предотвращает утечку реализации API и позволяет гибко изменять внутреннюю логику без влияния на внешние запросы.

##### Формат маркера страницы  
Наиболее удобный формат для маркера страницы — это строка. Использование чисел или байтов затрудняет обработку, особенно если нужно их зашифровать или кодировать. Обычно маркеры передаются в формате Base64, что удобно как для URL, так и для JSON.

##### Согласованность данных  
Важным моментом является обеспечение согласованности данных при пагинации. Если данные изменяются во время извлечения, например, новые элементы добавляются в коллекцию, это может привести к дублированию данных на разных страницах. Чтобы этого избежать, вместо смещения в маркере лучше использовать последний просмотренный элемент.

Для большей надёжности в работе API стоит использовать «снимки» данных, если база данных поддерживает эту функцию, что гарантирует, что данные останутся неизменными в процессе пагинации.

##### Продолжительность жизни маркеров  
Маркеры имеют ограниченный срок действия, обычно несколько минут или часов. Это важно учитывать, чтобы избежать ошибок при повторных запросах.

#### Общее количество данных  
В API часто возникает вопрос о необходимости предоставления общего числа результатов. Это может быть проблемным, особенно при больших объёмах данных, поскольку точный подсчёт требует значительных вычислительных ресурсов. Лучше избегать предоставления общего количества данных, если это не критично для пользователей.

#### Пагинация внутри ресурсов  
Когда один ресурс становится слишком большим, его можно разделить на фрагменты и использовать маркеры продолжения для навигации. Важно, чтобы данные оставались стабильными во время перелистывания страниц, а маски полей позволяли точно определять, какие данные доступны на каждой странице.

#### Компромиссы  
##### Двунаправленная пагинация  
Один из недостатков пагинации с маркерами — это невозможность двунаправленной навигации. Пагинация обычно позволяет двигаться только в одну сторону, от одной страницы к следующей. Вернуться к предыдущим данным невозможно без дополнительной логики, такой как хранение состояния на стороне клиента.

##### Произвольный выбор окна  
Пагинация с маркерами не поддерживает произвольный выбор окна данных. Для перехода к конкретной странице или набору данных нужно использовать фильтры и сортировку. Это решение больше подходит для программных интерфейсов, а не для интерфейсов с пользователем, где важен быстрый переход на конкретную страницу.

#### Антипаттерн: смещения и границы

Простое использование **смещений и границ** для пагинации — это распространённая практика, но она имеет несколько важных недостатков. Например, в запросах с использованием **OFFSET** и **LIMIT** могут возникнуть проблемы, когда в данных появляются новые элементы, что нарушает последовательность. Рассмотрим пример:

- Запрос с `OFFSET=30` и `LIMIT=10` может вернуть данные, которые уже были на предыдущей странице, если новые элементы были добавлены в базу данных.
  
Такой подход создаёт проблемы с масштабируемостью и может привести к непредсказуемым результатам. Смещение и границы зависят от конкретной реализации системы хранения данных, и любые изменения в ней могут нарушить последовательность пагинации.

Кроме того, использование смещений утечет детали реализации в API, что может затруднить поддержку и развитие системы.

##### Пример антипаттерна  
Предположим, у нас есть система чатов, и мы используем пагинацию с помощью смещений для получения сообщений:

```sql
SELECT * FROM messages WHERE chatroomid = 5 OFFSET 30 LIMIT 10
```

Однако, если в процессе извлечения данных добавляются новые сообщения, это может привести к тому, что запрос с `OFFSET=30` вернёт те же данные, что и предыдущий запрос. Это создаст дублирование информации и нарушит порядок отображения сообщений.

#### Резюме  
Пагинация — это удобный механизм для работы с большими объёмами данных. Она позволяет делить данные на страницы и использовать маркеры для продолжения запроса. Однако важно учитывать её ограничения и компромиссы, такие как невозможность двунаправленной навигации или проблемы с использованием смещений.

Хотите обсудить пагинацию или задать вопросы по этой теме? Пишите в комментариях! 👇

#заметки_из_книг